<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opus BLE Audio Decoder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 32px;
            max-width: 600px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            color: #333;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .header p {
            color: #666;
            font-size: 16px;
        }

        .section {
            margin-bottom: 24px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.4);
        }

        .status-indicator.connecting {
            background: #ffc107;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: #dc3545;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
        }

        .stat-item {
            text-align: center;
            padding: 16px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #333;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #f1aeb5;
            margin-top: 16px;
            display: none;
        }

        .success-message {
            background: #d1edff;
            color: #0c5460;
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #b8daff;
            margin-top: 16px;
            display: none;
        }

        .device-info {
            background: white;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin-top: 16px;
            display: none;
        }

        .buffer-indicator {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .buffer-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .latency-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .latency-good {
            background: #d4edda;
            color: #155724;
        }

        .latency-warning {
            background: #fff3cd;
            color: #856404;
        }

        .latency-danger {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 480px) {
            .app-container {
                padding: 20px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>Opus BLE Audio Decoder</h1>
            <p>Professional-grade audio streaming from Bluetooth Low Energy devices</p>
        </div>

        <!-- Bluetooth Connection Section -->
        <div class="section">
            <div class="section-title">
                <div class="status-indicator" id="connectionStatus"></div>
                Bluetooth Connection
            </div>
            <div class="controls-grid">
                <button class="btn" id="connectBtn">
                    <span>üì°</span> Connect Device
                </button>
                <button class="btn btn-danger" id="disconnectBtn" disabled>
                    <span>üîå</span> Disconnect
                </button>
            </div>
            <div class="device-info" id="deviceInfo">
                <strong>Device:</strong> <span id="deviceName">-</span><br>
                <strong>Service:</strong> <span id="serviceName">-</span><br>
                <strong>Signal:</strong> <span id="signalStrength">-</span>
            </div>
            <div class="error-message" id="connectionError"></div>
            <div class="success-message" id="connectionSuccess"></div>
        </div>

        <!-- Audio Controls Section -->
        <div class="section">
            <div class="section-title">
                üéµ Audio Controls
            </div>
            <div class="controls-grid">
                <button class="btn btn-secondary" id="playBtn" disabled>
                    <span>‚ñ∂Ô∏è</span> Play
                </button>
                <button class="btn btn-secondary" id="pauseBtn" disabled>
                    <span>‚è∏Ô∏è</span> Pause
                </button>
                <button class="btn btn-secondary" id="muteBtn" disabled>
                    <span>üîä</span> Mute
                </button>
            </div>
            <div class="volume-control">
                <span>üîâ</span>
                <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="75" disabled>
                <span id="volumeLabel">75%</span>
            </div>
        </div>

        <!-- Real-time Statistics Section -->
        <div class="section">
            <div class="section-title">
                üìä Real-time Statistics
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="packetCount">0</div>
                    <div class="stat-label">Packets</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="byteCount">0</div>
                    <div class="stat-label">Bytes</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="latencyValue">0ms</div>
                    <div class="stat-label">Latency</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="bufferHealth">0%</div>
                    <div class="stat-label">Buffer Health</div>
                </div>
            </div>
            <div class="buffer-indicator">
                <div class="buffer-fill" id="bufferFill"></div>
            </div>
        </div>
    </div>

    <script>
        class OpusBluetoothAudioDecoder {
            constructor() {
                this.device = null;
                this.characteristic = null;
                this.audioContext = null;
                this.worker = null;
                this.gainNode = null;
                this.isConnected = false;
                this.isPlaying = false;
                this.isMuted = false;
                this.volume = 0.75;
                this.audioQueue = [];
                this.stats = {
                    packets: 0,
                    bytes: 0,
                    latency: 0,
                    bufferHealth: 0
                };
                
                this.initializeElements();
                this.setupEventListeners();
                this.initializeAudioContext();
                this.initializeWorker();
            }

            initializeElements() {
                this.elements = {
                    connectionStatus: document.getElementById('connectionStatus'),
                    connectBtn: document.getElementById('connectBtn'),
                    disconnectBtn: document.getElementById('disconnectBtn'),
                    deviceInfo: document.getElementById('deviceInfo'),
                    deviceName: document.getElementById('deviceName'),
                    serviceName: document.getElementById('serviceName'),
                    signalStrength: document.getElementById('signalStrength'),
                    connectionError: document.getElementById('connectionError'),
                    connectionSuccess: document.getElementById('connectionSuccess'),
                    playBtn: document.getElementById('playBtn'),
                    pauseBtn: document.getElementById('pauseBtn'),
                    muteBtn: document.getElementById('muteBtn'),
                    volumeSlider: document.getElementById('volumeSlider'),
                    volumeLabel: document.getElementById('volumeLabel'),
                    packetCount: document.getElementById('packetCount'),
                    byteCount: document.getElementById('byteCount'),
                    latencyValue: document.getElementById('latencyValue'),
                    bufferHealth: document.getElementById('bufferHealth'),
                    bufferFill: document.getElementById('bufferFill')
                };
            }

            setupEventListeners() {
                this.elements.connectBtn.addEventListener('click', () => this.connectToDevice());
                this.elements.disconnectBtn.addEventListener('click', () => this.disconnectDevice());
                this.elements.playBtn.addEventListener('click', () => this.playAudio());
                this.elements.pauseBtn.addEventListener('click', () => this.pauseAudio());
                this.elements.muteBtn.addEventListener('click', () => this.toggleMute());
                this.elements.volumeSlider.addEventListener('input', (e) => this.setVolume(e.target.value));

                // Handle page unload
                window.addEventListener('beforeunload', () => {
                    if (this.isConnected) {
                        this.disconnectDevice();
                    }
                });

                // Handle audio context state changes
                document.addEventListener('click', () => {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                }, { once: true });
            }

            async initializeAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000,
                        latencyHint: 'interactive'
                    });

                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.connect(this.audioContext.destination);
                    this.gainNode.gain.value = this.volume;

                    console.log('Audio context initialized:', {
                        sampleRate: this.audioContext.sampleRate,
                        state: this.audioContext.state
                    });
                } catch (error) {
                    this.showError('Failed to initialize audio context: ' + error.message);
                }
            }

            async initializeWorker() {
                try {
                    this.worker = new Worker('opus-decoder-worker.js');
                    
                    this.worker.onmessage = (event) => {
                        const { type, data, error } = event.data;
                        
                        switch (type) {
                            case 'decoded':
                                this.handleDecodedAudio(data);
                                break;
                            case 'error':
                                this.showError('Decoder error: ' + error);
                                break;
                            case 'initialized':
                                console.log('Opus decoder worker initialized');
                                break;
                        }
                    };

                    this.worker.onerror = (error) => {
                        this.showError('Worker error: ' + error.message);
                    };

                    // Initialize the worker
                    this.worker.postMessage({ type: 'init' });
                } catch (error) {
                    this.showError('Failed to initialize audio worker: ' + error.message);
                }
            }

            async connectToDevice() {
                if (!navigator.bluetooth) {
                    this.showError('Web Bluetooth is not supported in this browser');
                    return;
                }

                try {
                    this.setConnectionStatus('connecting');
                    this.elements.connectBtn.disabled = true;

                    // Request device with audio service
                    this.device = await navigator.bluetooth.requestDevice({
                        filters: [{ namePrefix: 'Omi' }],
                        optionalServices: [
                            '19b10000-e8f2-537e-4f6c-d104768a1214'
                        ]
                    });

                    console.log('Selected device:', this.device.name);

                    // Connect to GATT server
                    const server = await this.device.gatt.connect();
                    console.log('Connected to GATT server');

                    // Get available services
                    const services = await server.getPrimaryServices();
                    console.log('Available services:', services.map(s => s.uuid));

                    // Find audio service and characteristic
                    let audioService = '19b10000-e8f2-537e-4f6c-d104768a1214';
                    let audioCharacteristic = '19b10001-e8f2-537e-4f6c-d104768a1214';

                    for (const service of services) {
                        try {
                            const characteristics = await service.getCharacteristics();
                            for (const char of characteristics) {
                                // Look for characteristics that support notifications (audio data)
                                if (char.properties.notify || char.properties.indicate) {
                                    audioService = service;
                                    audioCharacteristic = char;
                                    break;
                                }
                            }
                            if (audioCharacteristic) break;
                        } catch (error) {
                            console.log('Error accessing service:', service.uuid, error);
                        }
                    }

                    if (!audioCharacteristic) {
                        throw new Error('No suitable audio characteristic found');
                    }

                    this.characteristic = audioCharacteristic;

                    // Subscribe to notifications
                    await this.characteristic.startNotifications();
                    this.characteristic.addEventListener('characteristicvaluechanged', 
                        (event) => this.handleAudioData(event));

                    // Set up device disconnect handler
                    this.device.addEventListener('gattserverdisconnected', () => {
                        this.handleDisconnection();
                    });

                    this.isConnected = true;
                    this.setConnectionStatus('connected');
                    this.updateDeviceInfo();
                    this.enableAudioControls();
                    this.showSuccess('Successfully connected to ' + this.device.name);

                } catch (error) {
                    console.error('Connection failed:', error);
                    this.showError('Failed to connect: ' + error.message);
                    this.setConnectionStatus('disconnected');
                } finally {
                    this.elements.connectBtn.disabled = false;
                }
            }

            async disconnectDevice() {
                try {
                    if (this.characteristic) {
                        await this.characteristic.stopNotifications();
                    }
                    
                    if (this.device && this.device.gatt.connected) {
                        await this.device.gatt.disconnect();
                    }

                    this.handleDisconnection();
                    this.showSuccess('Device disconnected successfully');
                } catch (error) {
                    console.error('Disconnection error:', error);
                    this.showError('Error during disconnection: ' + error.message);
                }
            }

            handleDisconnection() {
                this.isConnected = false;
                this.device = null;
                this.characteristic = null;
                this.setConnectionStatus('disconnected');
                this.disableAudioControls();
                this.pauseAudio();
                this.hideDeviceInfo();
                this.resetStats();
            }

            handleAudioData(event) {
                const data = new Uint8Array(event.target.value.buffer);
                const timestamp = performance.now();

                // Update statistics
                this.stats.packets++;
                this.stats.bytes += data.length;
                this.updateStats();

                // Send to worker for decoding
                if (this.worker) {
                    this.worker.postMessage({
                        type: 'decode',
                        data: data,
                        timestamp: timestamp
                    });
                }
            }

            handleDecodedAudio(audioData) {
                if (!this.isPlaying || !this.audioContext) return;

                try {
                    // Create audio buffer
                    const audioBuffer = this.audioContext.createBuffer(
                        audioData.channels || 2,
                        audioData.samples.length / (audioData.channels || 2),
                        audioData.sampleRate || 48000
                    );

                    // Fill buffer with decoded data
                    if (audioData.channels === 1) {
                        audioBuffer.getChannelData(0).set(audioData.samples);
                    } else {
                        for (let channel = 0; channel < audioData.channels; channel++) {
                            const channelData = audioBuffer.getChannelData(channel);
                            for (let i = 0; i < channelData.length; i++) {
                                channelData[i] = audioData.samples[i * audioData.channels + channel];
                            }
                        }
                    }

                    // Queue for playback
                    this.audioQueue.push({
                        buffer: audioBuffer,
                        timestamp: audioData.timestamp || performance.now()
                    });

                    // Process audio queue
                    this.processAudioQueue();

                    // Update buffer health
                    this.updateBufferHealth();

                } catch (error) {
                    console.error('Error processing decoded audio:', error);
                }
            }

            processAudioQueue() {
                const currentTime = this.audioContext.currentTime;
                const maxQueueSize = 10; // Maximum number of buffered audio chunks

                // Remove old audio chunks
                while (this.audioQueue.length > maxQueueSize) {
                    this.audioQueue.shift();
                }

                // Play queued audio
                while (this.audioQueue.length > 0) {
                    const audioItem = this.audioQueue.shift();
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioItem.buffer;
                    source.connect(this.gainNode);
                    
                    // Schedule playback
                    const playTime = Math.max(currentTime, currentTime + 0.1);
                    source.start(playTime);

                    // Calculate latency
                    const latency = performance.now() - audioItem.timestamp;
                    this.stats.latency = latency;
                }
            }

            async playAudio() {
                try {
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    this.isPlaying = true;
                    this.elements.playBtn.disabled = true;
                    this.elements.pauseBtn.disabled = false;
                    console.log('Audio playback started');
                } catch (error) {
                    this.showError('Failed to start audio playback: ' + error.message);
                }
            }

            pauseAudio() {
                this.isPlaying = false;
                this.elements.playBtn.disabled = false;
                this.elements.pauseBtn.disabled = true;
                
                // Clear audio queue
                this.audioQueue = [];
                console.log('Audio playback paused');
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                
                if (this.gainNode) {
                    this.gainNode.gain.value = this.isMuted ? 0 : this.volume;
                }

                this.elements.muteBtn.innerHTML = this.isMuted ? 
                    '<span>üîá</span> Unmute' : '<span>üîä</span> Mute';
            }

            setVolume(value) {
                this.volume = value / 100;
                this.elements.volumeLabel.textContent = value + '%';
                
                if (this.gainNode && !this.isMuted) {
                    this.gainNode.gain.value = this.volume;
                }
            }

            setConnectionStatus(status) {
                this.elements.connectionStatus.className = `status-indicator ${status}`;
                this.elements.disconnectBtn.disabled = status !== 'connected';
            }

            enableAudioControls() {
                this.elements.playBtn.disabled = false;
                this.elements.muteBtn.disabled = false;
                this.elements.volumeSlider.disabled = false;
            }

            disableAudioControls() {
                this.elements.playBtn.disabled = true;
                this.elements.pauseBtn.disabled = true;
                this.elements.muteBtn.disabled = true;
                this.elements.volumeSlider.disabled = true;
            }

            updateDeviceInfo() {
                this.elements.deviceName.textContent = this.device.name || 'Unknown Device';
                this.elements.serviceName.textContent = this.characteristic.service.uuid;
                this.elements.signalStrength.textContent = 'Connected';
                this.elements.deviceInfo.style.display = 'block';
            }

            hideDeviceInfo() {
                this.elements.deviceInfo.style.display = 'none';
            }

            updateStats() {
                this.elements.packetCount.textContent = this.stats.packets.toLocaleString();
                this.elements.byteCount.textContent = this.formatBytes(this.stats.bytes);
                this.elements.latencyValue.textContent = Math.round(this.stats.latency) + 'ms';
            }

            updateBufferHealth() {
                const health = Math.min(100, (this.audioQueue.length / 5) * 100);
                this.stats.bufferHealth = health;
                this.elements.bufferHealth.textContent = Math.round(health) + '%';
                this.elements.bufferFill.style.width = health + '%';
            }

            resetStats() {
                this.stats = { packets: 0, bytes: 0, latency: 0, bufferHealth: 0 };
                this.updateStats();
                this.updateBufferHealth();
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            showError(message) {
                this.elements.connectionError.textContent = message;
                this.elements.connectionError.style.display = 'block';
                this.elements.connectionSuccess.style.display = 'none';
                setTimeout(() => {
                    this.elements.connectionError.style.display = 'none';
                }, 5000);
            }

            showSuccess(message) {
                this.elements.connectionSuccess.textContent = message;
                this.elements.connectionSuccess.style.display = 'block';
                this.elements.connectionError.style.display = 'none';
                setTimeout(() => {
                    this.elements.connectionSuccess.style.display = 'none';
                }, 3000);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            window.opusDecoder = new OpusBluetoothAudioDecoder();
            
            // Check for Web Bluetooth support
            if (!navigator.bluetooth) {
                document.querySelector('.app-container').innerHTML += `
                    <div class="error-message" style="display: block; margin-top: 20px;">
                        <strong>Web Bluetooth Not Supported</strong><br>
                        This application requires Web Bluetooth API support. Please use Chrome, Edge, or another compatible browser.
                    </div>
                `;
            }
        });
    </script>
</body>
</html>
